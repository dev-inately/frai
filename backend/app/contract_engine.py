"""
Contract generation engine for creating structured legal documents.
"""
import uuid
import time
from typing import List, Dict, Any, Optional
from loguru import logger
from jinja2 import Template

from .models import ContractSection, ContractType, BusinessContext, ContractGenerationRequest
from .ai_client import AIClient, AIClientError
from .database import db_manager


class ContractEngine:
    """Engine for generating and formatting contracts."""
    
    def __init__(self):
        """Initialize the contract engine."""
        self.ai_client = AIClient()
        self.html_template = self._load_html_template()
    
    def _load_html_template(self) -> Template:
        """Load the HTML template for contract formatting."""
        template_content = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ contract_type_title }} - {{ contract_id }}</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            margin: 2cm;
            color: #333;
        }
        .header {
            text-align: center;
            border-bottom: 2px solid #333;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        .company-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .contract-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .date {
            font-size: 14px;
            color: #666;
        }
        .section {
            margin-bottom: 25px;
        }
        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .subsection {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        .subsection-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #34495e;
        }
        .content {
            text-align: justify;
            margin-bottom: 10px;
        }
        .list {
            margin-left: 20px;
        }
        .list-item {
            margin-bottom: 5px;
        }
        .footer {
            margin-top: 50px;
            text-align: center;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }
        .page-break {
            page-break-before: always;
        }
        @media print {
            body { margin: 1cm; }
            .page-break { page-break-before: always; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="company-name">{{ contract_id }}</div>
        <div class="contract-title">{{ contract_type_title }}</div>
        <div class="date">Effective Date: {{ effective_date }}</div>
    </div>
    
    <div class="content">
        {{ contract_content | safe }}
    </div>
    
    <div class="footer">
        <p>This document was generated by AI Contract Generator. Please review with legal counsel before use.</p>
        <p>Generated on: {{ generation_date }}</p>
    </div>
</body>
</html>
"""
        return Template(template_content)
    
    async def generate_contract(
        self,
        request: ContractGenerationRequest
    ) -> Dict[str, Any]:
        """
        Generate a complete contract with proper formatting.
        
        Args:
            business_context: Business context for the contract
            contract_type: Type of contract to generate
            custom_sections: Optional custom sections
            language: Contract language
            jurisdiction: Legal jurisdiction
            
        Returns:
            Dictionary containing contract data and metadata
        """
        start_time = time.time()
        contract_id = str(uuid.uuid4())
        
        try:
            # Generate contract content using AI
            content_chunks = []
            async for chunk in self.ai_client.generate_contract_stream(
                request.business_context, 
                request.contract_type, 
                request.custom_sections, 
                request.language, 
            ):
                content_chunks.append(chunk)
            
            # Combine all chunks
            full_content = ''.join(content_chunks)
            
            # Parse and structure the content
            sections = self._parse_content_to_sections(full_content)
            
            # Generate HTML
            html_content = self._generate_html(
                request.contract_type, 
                contract_id,
                sections, 
            )
            
            generation_time = time.time() - start_time
            
            # Save to database
            await db_manager.save_contract(
                contract_id=contract_id,
                request=request,
                html_content=html_content,
                raw_content=full_content,
                sections=sections,
                total_sections=len(sections),
                estimated_pages=self._estimate_pages(sections),
                generation_time=round(generation_time, 2),
                model_used=self.ai_client.model
            )
            
            return {
                "contract_id": contract_id,
                "contract_type": request.contract_type,
                "sections": sections,
                "total_sections": len(sections),
                "estimated_pages": self._estimate_pages(sections),
                "generation_time": round(generation_time, 2),
                "model_used": self.ai_client.model,
                "html_content": html_content,
                "raw_content": full_content
            }
            
        except AIClientError as e:
            logger.error(f"AI client error in contract generation: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error in contract generation: {str(e)}")
            raise Exception(f"Contract generation failed: {str(e)}")
    
    def _parse_content_to_sections(self, content: str) -> List[ContractSection]:
        """
        Parse AI-generated content into structured sections.
        
        Args:
            content: Raw AI-generated content
            
        Returns:
            List of structured contract sections
        """
        sections = []
        lines = content.split('\n')
        current_section = None
        current_subsection = None
        section_number = 1
        subsection_number = 1
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Check for main section headers (h1, h2)
            if line.startswith('<h1>') or line.startswith('<h2>'):
                if current_section:
                    sections.append(current_section)
                
                title = line.replace('<h1>', '').replace('</h1>', '').replace('<h2>', '').replace('</h2>', '').strip()
                current_section = ContractSection(
                    title=title,
                    content=line,
                    section_number=section_number,
                    subsection_number=None
                )
                section_number += 1
                subsection_number = 1
                
            # Check for subsection headers (h3)
            elif line.startswith('<h3>'):
                if current_section:
                    current_section.content += '\n' + line
                
                title = line.replace('<h3>', '').replace('</h3>', '').strip()
                current_subsection = ContractSection(
                    title=title,
                    content=line,
                    section_number=section_number - 1,
                    subsection_number=subsection_number
                )
                subsection_number += 1
                
            # Regular content
            else:
                if current_section:
                    current_section.content += '\n' + line
        
        # Add the last section
        if current_section:
            sections.append(current_section)
        
        return sections
    
    def _generate_html(
        self,
        contract_type: str,
        contract_id: str,
        sections: List[ContractSection],
    ) -> str:
        """
        Generate formatted HTML for the contract.
        
        Args:
            business_context: Business context
            contract_type: Type of contract
            sections: Contract sections
            language: Contract language
            
        Returns:
            Formatted HTML string
        """
        import datetime
        
        # Format contract type for display
        contract_type_title = contract_type.replace("_", " ").title()
        
        # Current dates
        effective_date = datetime.datetime.now().strftime("%B %d, %Y")
        generation_date = datetime.datetime.now().strftime("%B %d, %Y at %I:%M %p")
        
        # Combine all section content
        contract_content = ""
        for section in sections:
            contract_content += section.content + "\n\n"
        
        # Render template
        html_content = self.html_template.render(
            contract_id=contract_id,
            contract_type_title=contract_type_title,
            effective_date=effective_date,
            generation_date=generation_date,
            contract_content=contract_content,
        )
        
        return html_content
    
    def _estimate_pages(self, sections: List[ContractSection]) -> int:
        """
        Estimate the number of pages the contract will occupy.
        
        Args:
            sections: Contract sections
            
        Returns:
            Estimated page count
        """
        total_content = ""
        for section in sections:
            total_content += section.content + "\n"
        
        # Rough estimate: 500 words per page
        word_count = len(total_content.split())
        estimated_pages = max(1, round(word_count / 500))
        
        return estimated_pages
    
    async def get_contract_types(self) -> List[Dict[str, str]]:
        """
        Get available contract types with descriptions.
        
        Returns:
            List of contract type information
        """
        return [
            {
                "value": ContractType.TERMS_OF_SERVICE,
                "label": "Terms of Service",
                "description": "Standard terms and conditions for service usage"
            },
            {
                "value": ContractType.PRIVACY_POLICY,
                "label": "Privacy Policy",
                "description": "Data collection and privacy practices"
            },
            {
                "value": ContractType.SERVICE_AGREEMENT,
                "label": "Service Agreement",
                "description": "Detailed service terms and conditions"
            },
            {
                "value": ContractType.NDA,
                "label": "Non-Disclosure Agreement",
                "description": "Confidentiality and non-disclosure terms"
            },
            {
                "value": ContractType.EMPLOYMENT_CONTRACT,
                "label": "Employment Contract",
                "description": "Employee terms and conditions"
            },
            {
                "value": ContractType.PARTNERSHIP_AGREEMENT,
                "label": "Partnership Agreement",
                "description": "Business partnership terms"
            }
        ]
